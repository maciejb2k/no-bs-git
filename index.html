<!DOCTYPE html>
<html lang="en">
  <head>
    <title>No BS Git</title>

    <!-- Meta -->
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="Learn Git once and for all." />
    <meta name="handheldfriendly" content="true" />
    <meta name="theme-color" content="#e84e31" />

    <!-- OG -->
    <meta property="og:title" content="No BS Git" />
    <meta property="og:description" content="Learn Git once and for all." />
    <meta
      property="og:image"
      content="https://maciejb2k.github.io/no-bs-git/assets/opengraph.jpg"
    />
    <meta property="og:url" content="https://maciejb2k.github.io/no-bs-git/" />
    <meta property="og:type" content="website" />

    <!-- Twitter -->
    <meta name="twitter:title" content="No BS Git" />
    <meta name="twitter:description" content="Learn Git once and for all." />
    <meta
      name="twitter:image"
      content="https://maciejb2k.github.io/no-bs-git/assets/opengraph.jpg"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="maciejb2k.github.io" />

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&family=Fira+Code&display=swap"
      rel="stylesheet"
    />

    <!-- Styles -->
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <script>
      const currentTheme = localStorage.getItem("theme");

      if (currentTheme == "dark") {
        document.body.classList.add("dark-theme");
      }
    </script>

    <div class="mobile-nav">
      <button class="mobile-nav__close">
        <svg
          class="h-6 w-6"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          stroke="currentColor"
          aria-hidden="true"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"
          />
        </svg>
      </button>
      <p class="nav__title">On this page:</p>
      <ul class="nav-list">
        <li>
          <a href="#" class="nav-link">Home</a>
        </li>
      </ul>
    </div>
    <div class="menu-background"></div>
    <header class="header">
      <div class="header__left">
        <a href="#">
          <img
            src="assets/logo_color.png"
            alt="text with name of the website"
            class="header__logo"
          />
        </a>
      </div>
      <div class="header__right">
        <a
          href="https://github.com/maciejb2k/no-bs-git"
          target="_blank"
          class="github-button"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            fill="currentColor"
            viewBox="0 0 1792 1792"
          >
            <path
              d="M896 128q209 0 385.5 103t279.5 279.5 103 385.5q0 251-146.5 451.5t-378.5 277.5q-27 5-40-7t-13-30q0-3 .5-76.5t.5-134.5q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105 20.5-150.5q0-119-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27t-83.5-38.5-85-13.5q-45 113-8 204-79 87-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-39 36-49 103-21 10-45 15t-57 5-65.5-21.5-55.5-62.5q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 88.5t.5 54.5q0 18-13 30t-40 7q-232-77-378.5-277.5t-146.5-451.5q0-209 103-385.5t279.5-279.5 385.5-103zm-477 1103q3-7-7-12-10-3-13 2-3 7 7 12 9 6 13-2zm31 34q7-5-2-16-10-9-16-3-7 5 2 16 10 10 16 3zm30 45q9-7 0-19-8-13-17-6-9 5 0 18t17 7zm42 42q8-8-4-19-12-12-20-3-9 8 4 19 12 12 20 3zm57 25q3-11-13-16-15-4-19 7t13 15q15 6 19-6zm63 5q0-13-17-11-16 0-16 11 0 13 17 11 16 0 16-11zm58-10q-2-11-18-9-16 3-14 15t18 8 14-14z"
            ></path>
          </svg>
          <span>GitHub</span>
        </a>
        <button class="btn-toggle">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20">
            <path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z"></path>
          </svg>
        </button>
        <button class="nav-toggle-button">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 1792 1792"
          >
            <path
              d="M1664 1344v128q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1536q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1536q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1536q26 0 45 19t19 45z"
            ></path>
          </svg>
        </button>
      </div>
    </header>
    <div class="container">
      <div class="wrapper">
        <aside class="nav">
          <p class="nav__title">On this page:</p>
          <ul class="nav-list">
            <li>
              <a href="#" class="nav-link">Home</a>
            </li>
          </ul>
        </aside>
        <div class="content">
          <main>
            <div class="group">
              <h2 class="heading heading--h2">Boring preface</h2>
              <p class="text">
                <b>Git is hard for beginners</b>. Do you have similar feelings?
                I think most of you can agree with that. Git was very hard for
                me, and after months of struggling with Git, I finally found out
                why.
              </p>
              <p class="text">
                <b
                  >In my opinion, the problem is about lack of a full
                  understanding of a
                  <span class="code">.git/</span> directory.</b
                >
              </p>
              <p class="text">
                <b>Git is not a blackbox, which somehow works</b>. By uneveiling
                the mystery behind the
                <span class="code">.git/</span> directory, you will be able to
                freely use Git in your projects without worries.
              </p>
            </div>

            <div class="group">
              <h2 class="heading heading--h2">Before we start</h2>
              <p class="text">
                <a href="https://git-scm.com/downloads" target="_blank"
                  >Install Git</a
                >
                and make sure it works by typing:
                <span class="code">git --version</span>
              </p>
              <p class="text">
                <b>You have to learn how to use Git from the command line</b>.
                If you want to understand it, you have to use it from the
                command line.
              </p>
              <p class="text">
                This guide assumes that
                <b>you are familiar with the basics of Git</b>, but it's often
                unclear to you how Git actually works, and how to deal with the
                common Git problems.
              </p>
            </div>

            <div class="group">
              <h2 class="heading heading--h2">Creating a Git repository</h2>
              <p class="text">
                <span class="code">git init</span> creates a hidden
                <span class="code">.git/</span>
                directory in the current location.
              </p>
              <p class="text">
                Git determines whether you are inside a Git repository by,
                checking if there is a <span class="code">.git/</span> directory
                at the root of the directory.
              </p>
              <p class="text text--label">
                Take a look what is inside
                <span class="code">.git/</span> directory:
              </p>
              <pre><code class="code-block language-bash">$ cd .git/ && ls -al

total 32K
-rw-r--r-- 1 maciejb maciejb   23 Sep  8 13:19 HEAD
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  8 13:19 branches
-rw-r--r-- 1 maciejb maciejb   92 Sep  8 13:19 config
-rw-r--r-- 1 maciejb maciejb   73 Sep  8 13:19 description
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  8 13:19 hooks
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  8 13:19 info
drwxr-xr-x 4 maciejb maciejb 4.0K Sep  8 13:19 objects
drwxr-xr-x 4 maciejb maciejb 4.0K Sep  8 13:19 refs</code></pre>
              <p class="text">
                Familirize yourself with these files and directories and don't
                do anything else for now. We will be focusing on the
                <span class="code">objects/</span> and
                <span class="code">refs/</span> directories in the next parts.
              </p>
            </div>

            <div class="group">
              <h2 class="heading heading--h2">SHA-1</h2>
              <p class="text">Everything in Git is based on <b>SHA-1</b>.</p>
              <p class="text">
                It is a
                <a href="https://en.wikipedia.org/wiki/SHA-1" target="_blank"
                  >cryptographic hash function</a
                >. You don't have to know how it mathematically works. You have
                to remember, that it takes any piece of text and turns it into
                <b>unique 40-character string of letters and numbers</b>. It's
                impossible to get back the original text from this unique
                string.
              </p>
              <div class="form">
                <div class="form__group">
                  <label for="sha1-input" class="form__label">Input:</label>
                  <input
                    class="form__input"
                    id="sha1-input"
                    type="text"
                    value="can horses swim?"
                  />
                </div>
                <div class="form__group">
                  <label for="sha1-output" class="form__label"
                    >SHA-1 Output:</label
                  >
                  <input
                    class="form__input"
                    id="sha1-output"
                    type="text"
                    disabled
                  />
                </div>
              </div>
              <p class="text">
                If you are wondering, what if SHA-1 will produce the same output
                for two different inputs, you can read about
                <a
                  href="https://en.wikipedia.org/wiki/Hash_collision"
                  target="_blank"
                  >collisions of hash functions</a
                >.
              </p>
              <p class="text">
                <b>Spoiler</b>: You will find that the probability of collision
                is extremly low. Also, you will learn that SHA-1 is not secure
                anymore, but it doesn't matter, because it is not used for
                security in Git.
              </p>
            </div>

            <div class="group">
              <h2 class="heading heading--h2">The primary role of Git</h2>
              <p class="text">
                At the lowest conceptual level, Git is just a simple
                <b>key:value</b> store.
              </p>
              <p class="text">
                It calculates the SHA-1 hash of the given input, which may be a
                text file, photo, pdf or anything else. Then it stores the input
                under the name of the calculated SHA-1 hash inside the
                <span class="code">.git/objects/</span> directory.
              </p>
              <p class="text">
                This explanation is very simplified, but it is enough for now,
                just to understand the core concept of Git.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Calculate SHA-1 in Git</h2>
              <p class="text">
                We can use one of the internal Git commands to calculate the
                SHA-1 hash of the given input with the
                <span class="code">git hash-object</span> command:
              </p>
              <p class="text text--label">You can try it by yourself:</p>
              <pre><code class="code-block language-bash">$ echo -n "can horses swim?" | git hash-object --stdin
4e91d48941493c77aa18db2cf7661c1fcb4b6ee8</code></pre>
              <p class="text text--label">
                Another example with the text file:
              </p>
              <pre><code class="code-block language-bash">$ echo -n "can horses swim?" > file.txt
$ git hash-object file.txt
4e91d48941493c77aa18db2cf7661c1fcb4b6ee8</code></pre>
              <p class="text">
                <b>Notice</b>: If you try to calculate SHA-1 from the same text
                using the hash calculation form from above and the
                <span class="code">git hash-object</span> command, you will
                notice that <b>the results are different</b>. Why is that?
              </p>
              <p class="text">
                To explain this behaviour, we need to introduce some new terms.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Types of objects in Git</h2>
              <p class="text">
                Everything in Git is expressed with "internal git objects".
              </p>
              <p class="text">
                Git has four types of objects:
                <span class="code">blob</span>, <span class="code">tree</span>,
                <span class="code">commit</span> and
                <span class="code">tag</span>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Blob</h2>
              <p class="text">Blob is a <b>generic piece of content</b>.</p>
              <p class="text">
                If you are using Git in your projects, your files with code are
                stored as Blobs inside the Git repository.
              </p>
              <p class="text">
                Blob is just a file, which is stored in the
                <span class="code">.git/objects/</span> directory.
              </p>
              <p class="text text--label">Blob is structured as follows:</p>
              <pre><code class="code-block language-bash">header + content</code></pre>
              <p class="text text--label">
                The <b>header</b> consists of the object type, which in our case
                is a blob, a single whitespace, its content size in bytes and a
                NULL byte:
              </p>
              <pre><code class="code-block language-bash">&lt;object type&gt; &lt;size of content in bytes&gt;\0

# Example header
blob 12\0</code></pre>
              <p class="text">
                The <b>content</b> is our input data (stdin, content of a file,
                etc.), which we want to store in the Git repository.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Creating a Blob</h2>
              <p class="text text--label">
                For instance, we want to create a Blob from the previous
                <span class="code">file.txt</span>:
              </p>
              <pre><code class="code-block language-bash">can horses swim?</code></pre>
              <p class="text text--label">
                The blob will look like this (header + content):
              </p>
              <pre><code class="code-block language-bash">blob 17\0can horses swim?</code></pre>
              <p class="text text--label">
                The <span class="code">git hash-object -w</span> command with a
                <span class="code">-w</span> flag creates and writes the blob to
                the <span class="code">.git/objects</span> directory.
              </p>
              <pre><code class="code-block language-bash">$ mkdir test-git-blobs
$ cd test-git-blobs
$ git init
$ echo -n "can horses swim?" > file.txt
$ git hash-object -w file.txt
4e91d48941493c77aa18db2cf7661c1fcb4b6ee8</code></pre>
              <p class="text">
                <b>Exercise:</b> Go ahead, and find that newly created blob
                inside the <span class="code">.git/objects</span> directory. Try
                to view the content of the blob.
              </p>
              <p class="text">
                You can play around with creating the blob using this form:
              </p>
              <div class="form">
                <div class="form__group">
                  <label for="blob-input" class="form__label"
                    >File content:</label
                  >
                  <input
                    class="form__input"
                    id="blob-input"
                    type="text"
                    value="can horses swim?"
                  />
                </div>
                <div class="form__group">
                  <label for="blob-sha1" class="form__label">SHA-1:</label>
                  <input
                    class="form__input"
                    id="blob-sha1"
                    type="text"
                    disabled
                  />
                </div>
                <div class="form__group">
                  <label for="blob-content" class="form__label"
                    >Blob (header + content):</label
                  >
                  <textarea
                    class="form__input"
                    name=""
                    id="blob-content"
                    cols="30"
                    rows="5"
                    disabled
                  ></textarea>
                </div>
                <div class="form__group">
                  <label for="blob-compressed" class="form__label"
                    >Compressed Blob (header + content) in HEX:</label
                  >
                  <textarea
                    class="form__input"
                    name=""
                    id="blob-compressed"
                    cols="30"
                    rows="5"
                    disabled
                  ></textarea>
                </div>
              </div>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Compressing the Blob</h2>
              <p class="text">
                As you may notice in the form above, there is an extra field
                with <b>compression</b>.
              </p>
              <p class="text">
                Git is smart enough to <b>compress</b> the content of the blob
                before it is stored in the
                <span class="code">.git/objects/</span> directory.
              </p>
              <p class="text">
                Git uses the
                <a href="https://en.wikipedia.org/wiki/Deflate" target="_blank"
                  >Deflate</a
                >
                data compression algorithm.
              </p>
              <p class="text">
                When Git saves the blob, it calculates the SHA-1 of the
                <b>raw blow</b>
                (header + content), then <b>compresses the blob</b> to a raw
                bytes and finally saves them under the name of hash:
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">How blobs are stored</h2>
              <p class="text text--label">
                Git groups the blobs in the directories by the
                <b>first two characters</b> of the blob. Our blob starts with
                the <span class="code">4e</span> prefix, so it is stored in the
                <span class="code">.git/objects/4e</span> directory:
              </p>
              <pre><code class="code-block language-bash">$ ls -l .git/objects/

total 12K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  9 09:01 4e
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  8 13:19 info
drwxr-xr-x 2 maciejb maciejb 4.0K Sep  8 13:19 pack

$ ls -l .git/objects/4e

total 4.0K
-r--r--r-- 1 maciejb maciejb 32 Sep  9 09:01 91d48941493c77aa18db2cf7661c1fcb4b6ee8</code></pre>
              <p class="text text--label">
                If you try to view the content of the file with the
                <span class="code">cat</span> command, you will get some random
                characters, se we will output hex bytes, the same way as in the
                form above with the <span class="code">hexdump</span> command:
              </p>
              <pre><code class="code-block language-bash">$ hexdump -v -e '1/1 "%02x"' 91d48941493c77aa18db2cf7661c1fcb4b6ee8

78014bcac94f52303463484ecc53c8c82f2a4e2d56282ecfccb5070061a2082c</code></pre>
              <p class="text">
                Of course nobody views the blobs in the Git repository like
                this, I want to demonstrate that the compression works. You can
                compare the results to the compression bytes from the form
                above.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Viewing the Blob</h2>
              <p class="text text--label"></p>
              <p class="text">
                To decompress and view <b>any Git object</b>, in our case the
                <b>Blob</b>, you should use the
                <span class="code">git cat-file &lt;SHA-1&gt;</span> command:
              </p>
              <p class="text">
                <b>Notice:</b> The command requires the SHA-1 hash of the blob,
                not the file name from the filesystem. You can provide only a
                few first characters of SHA-1 hash, as long as it is unique.
              </p>
              <p class="text text--label">
                The
                <span class="code">git cat-file</span> with
                <span class="code">-p</span> flag prints the content of the
                object, and the <span class="code">-t</span> flag prints the
                type of the object:
              </p>
              <pre><code class="code-block language-bash"># Full SHA-1 hash

$ git cat-file -p 4e91d48941493c77aa18db2cf7661c1fcb4b6ee8
can horses swim?
$ git cat-file -t 4e91d48941493c77aa18db2cf7661c1fcb4b6ee8
blob

# Short SHA-1 hash

$ git cat-file -p 4e91d489414
can horses swim?
$ git cat-file -t 4e91d4
blob</code></pre>
              <p class="text">
                Now you are familiar with the
                <span class="code">blob</span> object.
              </p>
              <p class="text">
                <b>Notice:</b> The <span class="code">blob</span> object
                introduced new problem - we have lost the <b>filename</b>,
                because the SHA-1 is only calculated from the content of the
                file, the filenames is ignored and the SHA-1 hash becomes the
                filename.
              </p>
              <p class="text">
                You will understand the solution to this problem when we start
                discussing <span class="code">tree</span> objects.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Note on git objects</h2>
              <p class="text">
                Each Git object is structured, compressed and stored (<span
                  class="code"
                  >.git/objects</span
                >) in the same way.
              </p>
              <p class="text text--label">
                The only difference is in the
                <b>object name</b> in the header, and in the <b>content</b>:
              </p>
              <pre><code class="code-block language-plain"># Object stucture
header + content

# Blob
blob &lt;content size in bytes&gt;\0&lt;content&gt;

# Tree
tree &lt;content size in bytes&gt;\0&lt;content&gt;

# Commit
commit &lt;content size in bytes&gt;\0&lt;content&gt;

# Tag
tag &lt;content size in bytes&gt;\0&lt;content&gt;</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Commits</h2>
              <p class="text">
                <b>Commit</b> is a <b>snapshot</b> of your project at a given
                time.
              </p>
              <p class="text">
                <span class="code">commit</span> is a second object type in Git.
              </p>
              <p class="text">
                Commits are stored in the
                <span class="code">.git/objects</span> directory.
              </p>
              <p class="text">
                To explain the <span class="code">commit</span> object, we need
                to prepare some files and directories in our git repository.
              </p>
              <p class="text text-label">
                Create a new directory and follow the instructions. Don't worry
                if you don't know the commands, we will cover them later.
              </p>
              <pre><code class="code-block language-bash">$ mkdir git-commits
$ cd git-commits
$ git init
$ mkdir dir1 dir2
$ echo -n "new file 1" > dir1/file1.txt
$ echo -n "new file 2" > dir2/file2.txt
$ echo -n "new file 3" > file3.txt
$ git add .
$ git commit -m "Init commit"
$ echo -n "new file 4" > file4.txt
$ git add .
$ git commit -m "Second commit"
$ git log
$ q
</code></pre>
              <p class="text text--label">What happened:</p>
              <ul class="list">
                <li class="list__item">
                  the command <span class="code">git add .</span> marked the new
                  files as ready to commit
                </li>
                <li class="list__item">
                  the command
                  <span class="code">git commit -m "Init commit"</span> saved
                  them to the git repository with message "Init commit".
                </li>
                <li class="list__item">
                  the command
                  <span class="code">git log</span> displayed list of commits
                </li>
              </ul>
              <p class="text text--label">
                Take a look at the <span class="code">git log</span> output:
              </p>
              <pre><code class="code-block language-bash">$ git log

commit 6bef83cf8560f8fc4994279afae86635cf1c394c (HEAD -> master)
Author: Maciej Biel &lt;example@email.com&gt;
Date:   Sun Sep 10 10:01:13 2023 +0200

  Second commit

commit 5d8da6e51bc54151677ba373cea0e13c9129eb6a (HEAD -> master)
Author: Maciej Biel &lt;example@email.com&gt;
Date:   Sun Sep 10 09:04:50 2023 +0200

  Init commit</code></pre>
              <p class="text">
                Do you remember the
                <span class="code">git cat-file</span> command from the previous
                sections?
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Inspecting the commit</h2>
              <p class="text">
                With the <span class="code">git cat-file</span> command we can
                inspect any object in the Git repository.
              </p>
              <p class="text text--label">
                Copy the SHA-1 of the commits from the
                <span class="code">git log</span> command and inspect the type
                of these objects:
              </p>
              <pre><code class="code-block language-plain">$ git cat-file -t 6bef83cf85

commit

$ git cat-file -t 5d8da6e51b

commit</code></pre>
              <p class="text text--label">
                Let's print the content of the commits:
              </p>
              <pre><code class="code-block language-plain">$ git cat-file -p 6bef83cf85

tree 01d7ad59ab92e3efe29f4347fe0b996d7188f580
parent 5d8da6e51bc54151677ba373cea0e13c9129eb6a
author Maciej Biel &lt;example@email.com&gt; 1694332873 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694332873 +0200

Second commit

$ git cat-file -p 5d8da6e51b

tree 384a95a8d3539872c6eab82dedf3ad0cc2cf11c2
author Maciej Biel &lt;example@email.com&gt; 1694329490 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694329490 +0200

Init commit</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Structure of the commit</h2>
              <p class="text">Commits are always structured in the same way:</p>
              <ul class="list">
                <li class="list__item">
                  bunch of headers like: <span class="code">tree</span>,
                  <span class="code">parent</span>,
                  <span class="code">author</span>, etc.
                </li>
                <li class="list__item">newline <span class="code">\n</span></li>
                <li class="list__item">commit message</li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Parents of the commit</h2>
              <pre><code class="code-block language-plain">parent 5d8da6e51bc54151677ba373cea0e13c9129eb6a</code></pre>
              <p class="text">
                The commit may have zero or multiple
                <span class="code">parent</span> headers.
              </p>
              <p class="text">
                When the commit is <b>the first commit</b> in the Git
                repository, it doesn't have a
                <span class="code">parent</span> header (<span class="code"
                  >5d8da6e51b</span
                >
                from previous section). It is the only commit in the repository
                without a <span class="code">parent</span> header.
              </p>
              <p class="text">
                Each next commit <b>must reference</b> it's previous commit
                using a <span class="code">parent</span> header and SHA-1 of the
                previous commit.
              </p>
              <p class="text">
                When the commit has multiple parents, it means that it is a
                <b>merge commit</b>, and it was created from multiple previous
                commits. We will talk about merging strategies later.
              </p>
              <p class="text">
                Commits are chained together using the
                <span class="code">parent</span> header. That means, Git history
                is not a <b>tree</b>, but a <b>DAG</b> (Directed Acyclic Graph).
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">
                Author and commiter of the commit
              </h2>
              <pre><code class="code-block language-plain">author Maciej Biel &lt;example@email.com&gt; 1694329490 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694329490 +0200</code></pre>
              <p class="text">
                The <b>author</b> is the person who wrote the code changes,
                while the <b>committer</b> is the one who added them to the
                repository.
              </p>
              <p class="text">
                For instance a <b>commiter</b> might be a GitHub when merging a
                pull request.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Tree</h2>
              <p class="text">
                The <span class="code">tree</span> is a thrid type of Git
                objects.
              </p>
              <p class="text">
                The <span class="code">tree</span> is very similar to a
                <b>UNIX directory</b>.
              </p>
              <p class="text">
                Combination of <span class="code">blobs</span> and
                <span class="code">trees</span> is used to reflect the project
                file structure within Git.
              </p>
              <p class="text">
                All the content from the <span class="code">commit</span> (files
                added to git during creation of commit) is stored using only
                <span class="code">blobs</span> or
                <span class="code">trees</span>.
              </p>
              <p class="text text--label">
                Let's inspect the <span class="code">tree</span> header from the
                <span class="code">5d8da6e51b</span> commit:
              </p>
              <pre><code class="code-block"># Inspecting the commit

$ git cat-file -p 5d8da6e51b

...
tree 384a95a8d3539872c6eab82dedf3ad0cc2cf11c2
...</code></pre>

              <pre><code class="code-block"># Inspecting the tree type

$ git cat-file -t 384a95a8d3

tree

# Inspecting the tree

$ git cat-file -p 384a95a8d3539

040000 tree cc0fea78ece05cc37dae4d302b4b3a0301595eb9    dir1
040000 tree ef56f0a20f52ca47f13c8c5a72d6b7a3a22a3534    dir2
100644 blob b037b2f50c795358d208ffb853999c7d14257773    file3.txt</code></pre>
              <p class="text">
                During creation of the <span class="code">commit</span>, Git
                creates a <span class="code">tree</span> object, which contains
                all the files and directories, starting from the root directory
                of the project, and writes them to the
                <span class="code">.git/objects</span> directory.
              </p>
              <p class="text">
                The <span class="code">tree</span> object solves the problem
                with <b>missing filename</b> during creation of the blob.
              </p>
              <p class="text text--label">
                We can lookup the <span class="code">tree</span> object
                corresponding to <span class="code">dir1</span> directory:
              </p>
              <pre><code class="code-block">$ git cat-file -p cc0fea78ece05c

100644 blob 4988b5e6c604b490401d0a1be9f6f8025b60781c    file1.txt</code></pre>
              <p class="text">
                Blobs are always <b>leafs</b> in the tree structure.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Structure of the tree row</h2>
              <pre><code class="code-block">040000 tree cc0fea78ece05cc37dae4d302b4b3a0301595eb9    dir1</code></pre>
              <p class="text text--label">
                Let's take a look at the first row. It consits of:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">040000</span> - file mode
                </li>
                <li class="list__item">
                  <span class="code">tree</span> - object type (<span
                    class="code"
                    >tree</span
                  >
                  or <span class="code">blob</span>)
                </li>
                <li class="list__item">
                  <span class="code"
                    >cc0fea78ece05cc37dae4d302b4b3a0301595eb9</span
                  >
                  - SHA-1 of the saved object in the
                  <span class="code">.git/objects</span>
                </li>
                <li class="list__item">
                  <span class="code">dir1</span> - name of the file / directory
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Space efficiency in commits</h2>
              <p class="text">
                Take a look at the SHA-1 of the
                <span class="code">file3.txt</span> in the tree from first
                commit and from the second commit. <b>It didn't change</b>. The
                same goes for the <span class="code">dir1</span>,
                <span class="code">dir2</span> directories and blobs inside
                them.
              </p>
              <pre><code class="code-block"># Second commit

$ git cat-file -p 01d7ad59ab92e3efe2

040000 tree cc0fea78ece05cc37dae4d302b4b3a0301595eb9    dir1
040000 tree ef56f0a20f52ca47f13c8c5a72d6b7a3a22a3534    dir2
100644 blob b037b2f50c795358d208ffb853999c7d14257773    file3.txt
100644 blob 86825070f391e4be005bc2c73f91057cc7e94b28    file4.txt

# First commit tree

$ git cat-file -p 384a95a8d353987

040000 tree cc0fea78ece05cc37dae4d302b4b3a0301595eb9    dir1
040000 tree ef56f0a20f52ca47f13c8c5a72d6b7a3a22a3534    dir2
100644 blob b037b2f50c795358d208ffb853999c7d14257773    file3.txt</code></pre>
              <p class="text">
                <b>Git saves space</b> by referencing in the next commits
                objects, which SHA-1 didn't change.
              </p>
              <p class="text">
                For instance, if the content of
                <span class="code">file3.txt</span> will change, Git wil create
                a new blob with a new SHA-1, and will reference it in the next
                commit.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Commits uneveiled</h2>
              <p class="text">
                That's all about commits!
                <b>No more magic behind the scenes</b>. You can always at any
                time inspect any Git object in the repository. The only thing
                you need is an SHA-1 of the object and that's it!
              </p>
              <p class="text text--label">
                Let's summarize what we have learned to that point:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">.git/objects</span> is a directory, which
                  acts as a <b>database</b> for Git objects.
                </li>
                <li class="list__item">
                  <span class="code">blobs</span>,
                  <span class="code">trees</span> and
                  <span class="code">commits</span> are <b>object types</b> in
                  Git, which are stored in the
                  <span class="code">.git/objects</span> directory.
                </li>
                <li class="list__item">
                  <span class="code">commit</span> is a <b>snapshot</b> of your
                  project, has a reference to the main
                  <span class="code">tree</span> object, which contains whole
                  <b>working directory structure</b>, and a reference to a
                  <b>parent commit</b>.
                </li>
                <li class="list__item">
                  <span class="code">tree</span> acts as a directory, contains
                  other <b>trees and blobs</b> with their names.
                </li>
                <li class="list__item">
                  <span class="code">blob</span> is a generic piece of content,
                  used to store <b>any file</b> from the working directory.
                </li>
              </ul>
              <img src="assets/git-object-model.png" alt="" class="image" />
              <div class="image-caption">
                Source:
                <a
                  href="http://shafiul.github.io/gitbook/1_the_git_object_model.html"
                  target="_blank"
                  >Git Community Book</a
                >
              </div>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Loose objects and compression</h2>
              <p class="text">
                Let's take a look at the
                <span class="code">.git/objects</span> directory and inspect the
                files after creating the commits in the previous section:
              </p>
              <pre><code class="code-block language-bash">ls -l .git/objects

total 48
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 01
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 38
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 49
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 5d
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 6b
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 86
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 8c
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 b0
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 cc
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 ef
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 info
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 pack</code></pre>
              <p class="text">
                All single files in the first ten directories, except the
                <span class="code">info</span> and
                <span class="code">pack</span> directories, are called
                <b>loose objects</b>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Packfiles</h2>
              <p class="text">
                Every object with different SHA-1 in Git repository is stored as
                a <b>separate object</b>.
              </p>
              <p class="text">
                <b
                  >Dealing with lots of small files on disk is very
                  inefficient.</b
                >
                Sending these files over the network too (have you ever pushed
                <span class="code">node_modules/</span> to GitHub ðŸ˜‚)?
              </p>
              <p class="text">
                Let's assume, we have a very long file which takes up 100KB of
                space on the disk. We commit it and then make a change in only
                one character in the file, so in the next commit, the
                <b>SHA-1 will change</b>.
              </p>
              <p class="text">
                Even though <b>99.9% of the file is the same</b> as before, Git
                must create a copy of the 100KB file in the next commit. This
                sound very space inefficient.
              </p>
              <p class="text">
                Fortunately, Git has a solution for this problem. To save space,
                Git combines multiple objects into a single file called a
                <b>packfile</b>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Packing objects</h2>
              <p class="text">
                Git has a built-in
                <a href="https://git-scm.com/docs/git-gc" target="_blank"
                  ><b>garbarge collector</b></a
                >, which runs from time to time (for instance on
                <span class="code">git push</span>) and packs
                <b>all the loose objects</b> into a <b>single packfiles</b>.
                This happens automatically, and we don't have to worry about it.
              </p>
              <p class="text">
                For learning purposes, we will pack the objects manually. To do
                that, we will use the <span class="code">git gc</span> command:
              </p>
              <pre><code class="code-block language-plain">$ ls -l .git/objects

total 48
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 01
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 38
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 49
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 5d
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 6b
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 10:01 86
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 8c
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 b0
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 cc
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 ef
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 info
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 09:04 pack

$ git gc

Enumerating objects: 10, done.
Counting objects: 100% (10/10), done.
Delta compression using up to 6 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (10/10), done.
Total 10 (delta 1), reused 0 (delta 0)

$ ls -l .git/objects

total 8
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 16:58 info
drwxr-xr-x 2 maciejb maciejb 4096 Sep 10 16:58 pack

$ ls -l .git/objects/pack

total 8
-r--r--r-- 1 maciejb maciejb 1352 Sep 10 16:58 pack-8d7a7a9ff4d59f249dd1d0f5963ab59402e0e2ca.idx
-r--r--r-- 1 maciejb maciejb  630 Sep 10 16:58 pack-8d7a7a9ff4d59f249dd1d0f5963ab59402e0e2ca.pack</code></pre>
              <p class="text">
                As you can see, Git packed all loose objects into
                <b>single packfile</b> and <b>packfile index</b>.
              </p>
              <p class="text">
                Usually, there <b>won't be any loose objects</b> in the
                <span class="code">.git/objects</span> directory, because the
                objects are stored in the packfiles.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Packfile and Packfile Index</h2>
              <p class="text">
                Thanks to packfiles, Git stores <b>original objects</b> once and
                then stores only a differences between <b>new objects</b> and
                <b>original ones</b> (deltas). Everything is compressed and
                stored in well organized format.
              </p>
              <p class="text">
                Another benefit is <b>reducing amount of small files</b> on the
                disk, so it's easier to manage them and send them over the
                network.
              </p>
              <p class="text">
                <span class="code">pack-[sha1].pack</span> stores
                <b>packed objects</b> with <b>computed deltas</b>.
              </p>
              <p class="text">
                <span class="code">pack-[sha1].idx</span> provides an index into
                <span class="code">pack-[sha1].pack</span>. It stores
                <b>information about the objects</b> in the packfile, including
                their SHA-1 hashes and the offset within the packfile where each
                object's compressed data starts.
              </p>
              <p class="text">
                In the example with one character change in 100KB file, Git
                <b>won't duplicate the new blob</b>, but will store only that
                one character difference compared to the original file.
              </p>
              <p class="text">
                This approach saves space <b>very efficiently</b>.
                <a href="https://git-scm.com/docs/pack-format" target="_blank"
                  >You can read more about packfiles here.</a
                >
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">The three trees</h2>
              <p class="text text--label">
                This term in Git describes, that there are three primary stages
                that represent the status of files in your project:
              </p>
              <ul class="list">
                <li class="list__item">Working Directory</li>
                <li class="list__item">Staging Area / Index</li>
                <li class="list__item">Local Repository / HEAD</li>
              </ul>
              <img
                src="assets/three-trees.jpg"
                alt="graphic showing flow between working directory, index and local repository"
                class="image image--margin"
              />
              <p class="text text--label">
                We will cover each of these stages briefly.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Working directory</h2>
              <p class="text">
                It's just a root directory, where
                <b>files from your project are stored</b>, and where Git
                repository is initialized. Nothing special.
              </p>
              <p class="text">
                Working directory is like a <b>sandbox</b>, where you can freely
                make changes, before you decide to save them to the Git
                repository.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Staging Area / Index</h2>
              <p class="text">
                When you finish work on the files in the working directory, it
                would be nice to have a place, where you can
                <b>prepare the commit</b>, i.e. select files, which should be
                included in the commit, review them and when everthing is ready,
                save them to the repository.
              </p>
              <p class="text">
                It's a place between the working directory and the local
                repository, where you can prepare and review files for the
                commit. It's your <b>proposed next commit</b>. That's exactly
                what the <b>staging area</b> (also called <b>index</b>) is for.
              </p>
              <p class="text">
                The command <span class="code">git add</span> is used to
                <b>add files</b> to the staging area.
              </p>
              <p class="text">
                How does <b>the staging area work</b>? It's not a separate place
                somewhere in the repository, but it is a file called
                <span class="code">.git/index</span>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">How does the Index works?</h2>
              <p class="text">
                <span class="code">.git/index</span> is a <b>binary file</b>,
                which stores entries about files in the repository and their
                hashes with some metadata.
              </p>
              <p class="text text--label">
                What does the <span class="code">.git/index</span> do:
              </p>
              <ol class="list">
                <li class="list__item">
                  It stores the current snapshot of all files
                  <b>added to the repository or to the index</b>, sorted
                  ascending by the <b>relative path</b> to the root directory of
                  the project.
                </li>
                <li class="list__item">
                  When creating a commit, the
                  <span class="code">tree</span> object, that will be included
                  in the commit, is created <b>based on the content</b> of the
                  <span class="code">.git/index</span>.
                </li>
                <li class="list__item">
                  It allows for <b>quick comparison of changes</b> between the
                  working directory / <span class="code">HEAD</span> and the
                  content of the index.
                </li>
                <li class="list__item">
                  It stores information <b>about merge conflicts</b>, when they
                  occur.
                </li>
              </ol>
              <p class="text">
                <span class="code">.git/index</span> is updated when
                <b>adding</b> or <b>removing</b> files from the staging area and
                the local repository or when <b>switching</b> between branches.
              </p>
              <p class="text text--label">
                We can view only <b>partial content</b> of the
                <span class="code">.git/index</span> file with the
                <span class="code">git ls-files</span> command:
              </p>
              <pre><code class="code-block language-plain">$ git ls-files --stage

100644 4988b5e6c604b490401d0a1be9f6f8025b60781c 0       dir1/file1.txt
100644 8c7f7ff45b68b6e818f2d4bc3ae6f43332d3ecf7 0       dir2/file2.txt
100644 b037b2f50c795358d208ffb853999c7d14257773 0       file3.txt
100644 86825070f391e4be005bc2c73f91057cc7e94b28 0       file4.txt

$ git ls-files --debug

dir1/file1.txt
  ctime: 1694688473:191235061
  mtime: 1694688473:191235061
  dev: 2080     ino: 839071
  uid: 1000     gid: 1000
  size: 10      flags: 0
dir2/file2.txt
  ctime: 1694688473:191235061
  mtime: 1694688473:191235061
  dev: 2080     ino: 839072
  uid: 1000     gid: 1000
  size: 10      flags: 0
file3.txt
  ctime: 1694688473:191235061
  mtime: 1694688473:191235061
  dev: 2080     ino: 839073
  uid: 1000     gid: 1000
  size: 10      flags: 0
file4.txt
  ctime: 1694688473:201235061
  mtime: 1694688473:201235061
  dev: 2080     ino: 839090
  uid: 1000     gid: 1000
  size: 10      flags: 0</code></pre>
              <p class="text text--label">
                <a
                  href="https://github.com/git/git/blob/867b1c1bf68363bcfd17667d6d4b9031fa6a1300/Documentation/technical/index-format.txt#L38"
                  target="_blank"
                  >Not every property is displayed with the git ls-files
                  command</a
                >. For each file, <span class="code">.git/index</span> stores
                following properties:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">ctime</span> -
                  <span class="code">[seconds]:[nanoseconds]</span> - the last
                  time when the file's <b>metadata changed</b>.
                </li>
                <li class="list__item">
                  <span class="code">mtime</span> -
                  <span class="code">[seconds]:[nanoseconds]</span> - the last
                  time when the file's <b>content changed</b>, ignoring metadata
                  changes.
                </li>
                <li class="list__item">
                  <span class="code">dev</span> - identifies hardware device
                  where the file is stored on.
                </li>
                <li class="list__item">
                  <span class="code">ino</span> - number of the file's assigned
                  <span class="code">inode</span>.
                </li>
                <li class="list__item">
                  <span class="code">uid</span>, <span class="code">uid</span> -
                  user's id and group id.
                </li>
                <li class="list__item">
                  <span class="code">fname</span> - filename with a relative
                  path.
                </li>
                <li class="list__item">
                  <span class="code">flags</span> - we will talk about it in the
                  <a
                    href="https://maciejb2k.github.io/no-bs-git/#what-happens-when-the-merge-conflict-occurs"
                    >merge conflicts section</a
                  >.
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Adding new files to the Index</h2>
              <p class="text">
                In this section, <b>you can observe</b>, how does the
                <span class="code">.git/index</span> works in action, and how
                it's content change when files are added and commited.
              </p>
              <p class="text text--label">Take a look at this scenario:</p>
              <pre><code class="code-block language-plain">$ echo -n "new file 5" > file5.txt

$ ll .git/objects

total 8.0K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:55 info
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:55 pack

$ git ls-files --stage

100644 4988b5e6c604b490401d0a1be9f6f8025b60781c 0       dir1/file1.txt
100644 8c7f7ff45b68b6e818f2d4bc3ae6f43332d3ecf7 0       dir2/file2.txt
100644 b037b2f50c795358d208ffb853999c7d14257773 0       file3.txt
100644 86825070f391e4be005bc2c73f91057cc7e94b28 0       file4.txt

$ git status

On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        file5.txt

nothing added to commit but untracked files present (use "git add" to track)

$ git add file5.txt

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        new file:   file5.txt

$ ll .git/objects

total 12K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:42 14
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 info
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 pack

$ git ls-files --stage

100644 4988b5e6c604b490401d0a1be9f6f8025b60781c 0       dir1/file1.txt
100644 8c7f7ff45b68b6e818f2d4bc3ae6f43332d3ecf7 0       dir2/file2.txt
100644 b037b2f50c795358d208ffb853999c7d14257773 0       file3.txt
100644 86825070f391e4be005bc2c73f91057cc7e94b28 0       file4.txt
100644 1463a3913b7f3ed15583d64cf7fb528e1cb39634 0       file5.txt</code></pre>
              <p class="text text--label">Let's explain what happened:</p>
              <ul class="list">
                <li class="list__item">
                  We added a new file <span class="code">file5.txt</span>.
                </li>
                <li class="list__item">
                  No new objects in <span class="code">.git/objects/</span> were
                  created at this point.
                </li>
                <li class="list__item">
                  File is not included in the
                  <span class="code">.git/index</span>.
                </li>
                <li class="list__item">
                  The new file is untracked in
                  <span class="code">git status</span>.
                </li>
                <li class="list__item">
                  We staged the file using the
                  <span class="code">git add</span> command.
                </li>
                <li class="list__item">
                  The new file is now staged in the repository.
                </li>
                <li class="list__item">
                  A new object was created in the
                  <span class="code">.git/objects/</span> directory for
                  <span class="code">file5.txt</span>. This action was performed
                  by the <span class="code">.git/index</span>.
                </li>
                <li class="list__item">
                  A new entry was added to the
                  <span class="code">.git/index</span> for
                  <span class="code">file5.txt</span>.
                </li>
              </ul>
              <p class="text text--label">
                Now, lets modify the <span class="code">file5.txt</span> and add
                it again to the repository:
              </p>
              <pre><code class="code-block language-plain">$ echo -n "new file 6" > file5.txt

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        new file:   file5.txt

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
        modified:   file5.txt

$ ll .git/objects

total 12K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:42 14
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 info
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 pack

$ git ls-files --stage

100644 4988b5e6c604b490401d0a1be9f6f8025b60781c 0       dir1/file1.txt
100644 8c7f7ff45b68b6e818f2d4bc3ae6f43332d3ecf7 0       dir2/file2.txt
100644 b037b2f50c795358d208ffb853999c7d14257773 0       file3.txt
100644 86825070f391e4be005bc2c73f91057cc7e94b28 0       file4.txt
100644 1463a3913b7f3ed15583d64cf7fb528e1cb39634 0       file5.txt

$ git add file5.txt

$ ll .git/objects

total 16K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:42 14
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:45 d7
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 info
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 11 15:41 pack

$ git ls-files --stage

100644 4988b5e6c604b490401d0a1be9f6f8025b60781c 0       dir1/file1.txt
100644 8c7f7ff45b68b6e818f2d4bc3ae6f43332d3ecf7 0       dir2/file2.txt
100644 b037b2f50c795358d208ffb853999c7d14257773 0       file3.txt
100644 86825070f391e4be005bc2c73f91057cc7e94b28 0       file4.txt
100644 d7bd1b39072cb3ddc0e503f51aab7e7e0e39539b 0       file5.txt</code></pre>
              <p class="text text--label">What happened this time:</p>
              <ul class="list">
                <li class="list__item">
                  We modified the content of the
                  <span class="code">file5.txt</span>.
                </li>
                <li class="list__item">
                  In the <span class="code">git status</span>, previous version
                  of the <span class="code">file5.txt</span> is still staged (is
                  added to the <span class="code">.git/index</span>), new
                  version appears as modified.
                </li>
                <li class="list__item">
                  The <span class="code">.git/index</span> shows entry with
                  version of <span class="code">file5.txt</span> before
                  modification.
                </li>
                <li class="list__item">
                  We stage the file again using the
                  <span class="code">git add</span> command.
                </li>
                <li class="list__item">
                  The <span class="code">.git/index</span> is updated with the
                  new version of the <span class="code">file5.txt</span>.
                </li>
                <li class="list__item">
                  In the <span class="code">.git/objects/</span> we can see
                  previous version of the <span class="code">file5.txt</span>,
                  which became a <b>dangling object</b> (an object without any
                  reference in the repository - garbage collector will remove
                  this file by default
                  <a href="https://git-scm.com/docs/git-gc" target="_blank"
                    >after 90 days</a
                  >).
                </li>
              </ul>
              <p class="text">
                How does Git know <b>what status a particular file has</b> in
                the working directory and whether it qualifies as "Changes to be
                committed" or "Changes not staged for commit"? You will find out
                in the <a href="#git-status">next section</a> about the
                <span class="code">git status</span> command.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Summary about the index</h2>
              <p class="text">
                Take this overview of the
                <span class="code">.git/index</span> internals with a
                <b>grain of salt</b>.
              </p>
              <p class="text">
                Probably you won't use that knowledge in real life, but I
                recommend you to try out different scenarious
                <b>by yourself</b> if you are interested in it's underlying
                mechanics.
              </p>
              <p class="text">
                Explanation from
                <a href="#staging-area-/-index">this section</a> is enough, if
                you understand the basic concept of the staging area, which is
                just a <b>propose of the new commit</b>.
              </p>
              <img src="assets/index-view.png" alt="" class="image" />
              <div class="image-caption">
                Source:
                <a
                  href="https://github.blog/2021-11-10-make-your-monorepo-feel-small-with-gits-sparse-index/"
                  target="_blank"
                  >GitHub Blog</a
                >
              </div>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Git Status</h2>
              <p class="text">
                <span class="code">git status</span> shows
                <b>what's going on right now</b> in the repository.
              </p>
              <p class="text text--label">
                <span class="code">git status</span> shows:
              </p>
              <ul class="list">
                <li class="list__item">
                  state of a repository on a current branch.
                </li>
                <li class="list__item">
                  untracked files (not commited previously).
                </li>
                <li class="list__item">
                  differences between <span class="code">.git/index</span> and
                  <span class="code">HEAD</span>.
                </li>
                <li class="list__item">
                  differences between <span class="code">.git/index</span> and
                  <span class="code">working directory</span>.
                </li>
                <li class="list__item">
                  state of a merge conflict, if it occurs.
                </li>
              </ul>
              <p class="text">
                It's a good practice to often run this command, before
                performing any <b>state altering operations</b>.
              </p>
              <p class="text">
                <span class="code">git status</span> is
                <b>closely linked</b> with the
                <span class="code">.git/index</span> file, it enables
                <b>identification</b> of the current states of files in the
                repository.
              </p>
              <p class="text text--label">
                Common states of files in the
                <span class="code">git status</span>:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">untracked</span> - the file is
                  <b>not present</b> in the latest commit (there is no entry for
                  this file in the <span class="code">.git/index</span>).
                </li>
                <li class="list__item">
                  <span class="code">new file</span> - the file is
                  <b>not present</b> in the latest commit, but is
                  <b>staged / added</b> to the
                  <span class="code">.git/index</span>.
                </li>
                <li class="list__item">
                  <span class="code">modified</span> - the file
                  <b>is present</b> in the latest commit, but it's content was
                  <b>modified</b> in the working directory.
                </li>
                <li class="list__item">
                  <span class="code">deleted</span> - the file
                  <b>is present</b> in the latest commit, but it is deleted in
                  the working directory.
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Local repository</h2>
              <p class="text">
                When the files are staged and ready to be saved to the
                repository, using the
                <span class="code">git commit</span> command, they are persisted
                in the local repository.
              </p>
              <p class="text">
                The files in the local repository are
                <span class="code">commit</span> objects in the
                <span class="code">.git/objects/</span> directory.
              </p>
              <p class="text">
                The <span class="code">tree</span> in the
                <span class="code">commit</span> object is created based on the
                content of the <span class="code">.git/index</span>. After
                creating the commit, the properties in the
                <span class="code">.git/index</span> are accordingly updated.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Branches</h2>
              <p class="text">
                Branches are used as <b>independent lines of development</b>.
                But what is branch itself?
              </p>
              <p class="text">
                Branch is a <b>named reference to the commit</b>.
              </p>
              <p class="text">
                That's it. Sounds simple, but confusing at the same time. Let's
                take a closer look at the branches inside the
                <span class="code">.git/</span> directory.
              </p>
              <p class="text">
                Branches, or more precisely, <b>references to a commits</b> are
                stored inside the
                <span class="code">.git/refs/</span> directory.
              </p>
              <pre><code class="code-block">$ ll .git/refs

total 12K
drwxr-xr-x 3 maciejb maciejb 4.0K Sep  5 16:07 heads
drwxr-xr-x 3 maciejb maciejb 4.0K Aug 30 09:35 remotes
drwxr-xr-x 2 maciejb maciejb 4.0K Jul  5 20:57 tags

$ ll .git/refs/heads

total 4.0K
-rw-r--r-- 1 maciejb maciejb 41 Sep 11 16:50 master</code></pre>
              <p class="text text--label">
                Inside the <span class="code">.git/refs</span> directory there
                are three other directories:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">heads</span> - stores local branches.
                </li>
                <li class="list__item">
                  <span class="code">remotes</span> - stores remote branches.
                </li>
                <li class="list__item">
                  <span class="code">tags</span> - stores lightweight tags, we
                  will talk about them later.
                </li>
              </ul>
              <p class="text text--label">
                Let's take a closer look at the local branches:
              </p>
              <pre><code class="code-block">$ ll .git/refs/heads

total 4.0K
-rw-r--r-- 1 maciejb maciejb 41 Sep 11 16:50 master

$ cat .git/refs/heads/master

bf44270dcf4abb61d7c5062123bb054a3770f8dd</code></pre>
              <p class="text">
                When the repository is initialized, the default branch is
                created, usually called <b>master</b> or <b>main</b>.
              </p>
              <p class="text">
                A branch is a <b>text file</b>, which name is the
                <b>name of the branch</b>, and the content is the
                <b>SHA-1 of the commit, which the branch points to</b>. It's
                that simple.
              </p>
              <p class="text">
                When a new commit is created, the branch we are currently on is
                updated with the <b>SHA-1 of the new commit</b>, so the branch
                moves forward with each new commit.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">HEAD</h2>
              <p class="text">
                How do Git know on <b>which branch we are currently on</b>? It's
                stored in the <span class="code">.git/HEAD</span> file.
              </p>
              <pre><code class="code-block">$ cat .git/HEAD

ref: refs/heads/master</code></pre>
              <p class="text">
                The <span class="code">.git/HEAD</span> is a text file, which
                stores <b>path to a branch</b> from the
                <span class="code">.git/refs/heads</span> directory.
              </p>
              <p class="text">
                When we switch branches, the
                <span class="code">.git/HEAD</span> is updated with the
                <b>new path</b>
                to the branch.
              </p>
              <p class="text">
                We can use the <b>currently used branch name</b> with the
                <span class="code">HEAD</span> interchangeably. It will be
                resolved to the <b>SHA-1 of the commit</b>, which the branch
                points to.
              </p>
              <pre><code class="code-block language-plain">$ git cat-file -p HEAD

tree ca832d9a2eda0108a3364a250a07a9124ff33fd1
parent aa656d4a755d144e68571585e33bf9c67a0b247c
author Maciej Biel &lt;example@email.com&gt; 1694443839 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694443839 +0200

Third commit

$ git cat-file -p master

tree ca832d9a2eda0108a3364a250a07a9124ff33fd1
parent aa656d4a755d144e68571585e33bf9c67a0b247c
author Maciej Biel &lt;example@email.com&gt; 1694443839 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694443839 +0200

Third commit

$ git cat-file -p bf44270

tree ca832d9a2eda0108a3364a250a07a9124ff33fd1
parent aa656d4a755d144e68571585e33bf9c67a0b247c
author Maciej Biel &lt;example@email.com&gt; 1694443839 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694443839 +0200

Third commit</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Packed Refs</h2>
              <p class="text">
                By default, all references are stored inside the
                <span class="code">.git/refs</span> directory.
              </p>
              <p class="text">
                One day you may notice, that the there <b>aren't any references</b>
                inside the <span class="code">.git/refs</span>.
              </p>
              <p class="text">
                It's because <b>single references</b> are the same
                <b>loose objects</b>, like objects <a href="#loose-objects-and-compression">from .git/objects directory</a>, and the
                same problems applies to them with space and network efficiency.
              </p>
              <p class="text">References are packed into a <b>single file</b> called: <span class="code">.git/packed-refs</span>.</p>
              <p class="text text--label">The process of packing refs <b>happens automatically</b>, but we can do it manually with the <span class="code">git pack-refs</span> command:</p>
              <pre><code class="code-block language-plain">$ ll .git/refs/heads

total 4.0K
-rw-r--r-- 1 maciejb maciejb 41 Sep 11 16:50 master

$ git pack-refs --all

$ ll .git/refs/heads
total 0

$  cat .git/packed-refs

# pack-refs with: peeled fully-peeled sorted
bf44270dcf4abb61d7c5062123bb054a3770f8dd refs/heads/master</code></pre>
              <p class="text">Git checks first, whether the branch exists in the <span class="code">.git/refs/</span> directory, then lookups the <span class="code">.git/packed-refs</span> file.</p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Relative paths</h2>
              <p class="text text--label">
                We can use relative paths to reference commits:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">HEAD^[num]</span> - selects
                  <span class="code">parent</span> header from the commit.

                  <ul class="nested-list">
                    <li>
                      <span class="code">HEAD^1</span> selects the first parent.
                    </li>
                    <li>
                      <span class="code">HEAD^2</span> selects the second
                      parent.
                    </li>
                    <li>
                      <span class="code">HEAD^^2</span> selects the second
                      parent from the previous commit.
                    </li>
                    <li>
                      <span class="code">HEAD^2^3</span> selects the second
                      parent from the commit to which HEAD points, and the third
                      parent from the second commit.
                    </li>
                    <li>
                      <span class="code">HEAD^^</span> moves back by two
                      commits.
                    </li>
                  </ul>
                </li>
                <li class="list__item">
                  <span class="code">HEAD~[num]</span> - gets back a certain
                  number of commits, including the
                  <span class="code">HEAD</span>.
                  <ul class="nested-list">
                    <li>
                      <span class="code">HEAD~</span> selects previous commit.
                    </li>
                    <li>
                      <span class="code">HEAD~1</span> does the same as
                      <span class="code">HEAD~</span>.
                    </li>
                    <li>
                      <span class="code">HEAD~3</span> selects
                      <span class="code">HEAD - 3</span> commit.
                    </li>
                    <li>
                      <span class="code">HEAD~^2~2</span> selects a commit by
                      going back two commits from the second parent of the
                      previous commit.
                    </li>
                  </ul>
                </li>
              </ul>
              <p class="text">
                Instead of <span class="code">HEAD</span>, you can also use the
                <b>branch name</b> or the <b>commit hash</b>. It will work in
                the same way.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Reachability of the commits</h2>
              <p class="text">
                Commits can be <b>reachable</b> or
                <b>unreachable / dangling</b>. Take a look at the diagram below:
              </p>
              <img
                src="assets/reachability.jpg"
                alt="flow showing reachability of the commits"
                class="image image--margin"
              />
              <p class="text">
                When a branch references a commit, all of its ancestor commits
                (parent commits) <b>become reachable</b>, starting from the
                first commits to which the branches on the diagram points.
              </p>
              <p class="text">
                All of the grey commits are <b>unreachable</b>, because none of
                the branches points to them.
              </p>
              <p class="text">
                <b>Important note:</b> The unreachable commits will remain in
                the <span class="code">.git/objects/</span> directory in the
                repository <b>for the next 90 days</b>.
              </p>
              <p class="text">
                Even if you delete the branch and the commits are no longer
                visible in the
                <span class="code">git log</span>, they are not deleted and will
                be kept in the local repository for some time.
              </p>
              <p class="text">
                If you know the <b>SHA-1</b> of the unreachable commits (for
                instance from <span class="code">git reflog</span>) you can
                still checkout to them, create a branch on that commit, and they
                will become <b>reachable again</b>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Detached HEAD</h2>
              <p class="text">
                This is a situation, when the
                <span class="code">.git/HEAD</span> file points
                <b>directly to the commit</b>, instead to the tip of the branch.
              </p>
              <p class="text">
                The <span class="code">89bv5fa</span> commit in a diagram above
                is an example of a commit, which was created in the detached
                HEAD mode. None of the branches points to this commit, so it's a
                <b>dangling commit</b>.
              </p>
              <pre><code class="code-block language-plain">test-repo git:(master) git checkout 89bv5fa

Note: switching to '89bv5fa'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c &lt;new-branch-name&gt;

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 89bv5fa Unreachable commit
test-repo git:(89bv5fa)</code></pre>
              <p class="text">
                Any new commits created in this state <b>will be lost</b> after
                switching back to a branch, beacuse they won't be referenced by
                any branch (reachability).
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Merging strategies</h2>
              <p class="text">
                Merging in Git is the process of <b>combining changes</b> from
                one branch into another branch.
              </p>
              <p class="text text--label">
                Git offers four different strategies for merging branches:
              </p>
              <ul class="list">
                <li class="list__item">Fast forward</li>
                <li class="list__item">Three way merge</li>
                <li class="list__item">Squash</li>
                <li class="list__item">Rebase</li>
              </ul>
              <p class="text">
                To find differences and changes between the files, Git uses the
                <a href="http://www.xmailserver.org/diff2.pdf" target="_blank"
                  >Myers diff algorithm</a
                >.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Fast forward merge</h2>
              <p class="text">
                This is the simplest type of merge. The only thing that happens
                is that the <b>branch pointer is moved forward</b>.
              </p>
              <p class="text">
                Fast forward is by default performed when executing:
                <span class="code">git merge</span>.
              </p>
              <p class="text text--label">
                Take a look what's happening under the hood:
              </p>
              <pre><code class="code-block language-bash">$ cat .git/refs/heads/master
3736ef1bf7c3e7f197d597357840f1e0b69689e5

$ cat .git/refs/heads/new_branch
8b3783ac86019bb0ab0dc5b62c3abdb8c3964485

$ git checkout master
Switched to branch â€˜masterâ€™

$ git merge new_branch
Updating 3736ef1..8b3783a
Fast-forward
new_file.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 new_file.txt

$ cat .git/refs/heads/master
8b3783ac86019bb0ab0dc5b62c3abdb8c3964485</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Three way merge</h2>
              <p class="text">
                When we do a merge in Git, we take two commits, calculate the
                difference between them, and create a new <b>merge commit</b>.
              </p>
              <p class="text">
                That's what we'd call a two-way merge. However, Git actually
                does <b>three comparisons, not just two</b>.
              </p>
              <p class="text">
                We call it a <b>three-way merge</b> because Git also considers
                the common ancestor of those two commits. This helps us
                understand who made what changes and how to combine them when
                creating the merge commit.
              </p>
              <p class="text">
                It's like <b>having a reference point</b> to figure out what to
                include from both sides.
              </p>
              <p class="text">
                When the fast forward can't be performed, Git will fallback to
                three way merge, but we can explicitly specify to perform this
                type of merge using
                <span class="code">git merge --no-ff</span>.
              </p>
              <p class="text">
                To demonstrate, why Git uses the
                <b>three way merge</b> strategy, rather than the
                <b>two way merge</b>, let's take a look at the following
                scenario:
              </p>
              <pre><code class="code-block language-plain">Base commit:
a
b
c

Changes introduced by Commiter #1 on branch feature/1:
a &lt;- [deleted]
b &lt;- [modified]
c &lt;- [modified]

Changes introduced by Commiter #2 on branch feature/2:
a &lt;- [modified]
b &lt;- [modified]
c &lt;- [modified]
d &lt;- [modified]

Two-way merge (merge feature/1 with feature2, without base commit, deletion by Commiter #1 is present again, so this merge doesn't make any sense):
a
b
c
d

Three way merge (merge feature/1 with feature2, including base commit, deletion by Commiter #1 is no longer present and this makes sense):
b
c
d</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Merge commit</h2>
              <p class="text">
                It's a regular commit created during the merge. The only
                difference, is that it has <b>more than one parent commit</b>.
              </p>
              <pre><code class="code-block language-plain">tree [hash of the merged tree]
parent [hash of the commit from main]
parent [hash of the commit from develop]
author [author name and email]
committer [committer name and email]

Merge branch '[develop]'</code></pre>
              <p class="text">
                When performing three way merge, the history of merged branch is
                <b>visible in the log</b>, because of the
                <span class="code">parent</span> header, with reference to
                commits from the merged branch.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Squash merge</h2>
              <p class="text">
                Squash merge <b>combines all commits</b> from the merged branch
                into a <b>single one</b> and creates a merge commit at the tip
                of the main branch.
              </p>
              <p class="text">
                The most important thing about the squash merge is that it
                creates a merge commit, which <b>has only one parent commit</b>.
              </p>
              <p class="text">
                There is <b>no reference</b> to commits from merged branch (only
                one <span class="code">parent</span> header). It makes
                <b>history cleaner</b>, but we are losing information about the
                merged branch.
              </p>
              <p class="text">
                Squash command itself doesn't exist in Git (<span class="code"
                  >git squash</span
                >), but it's <b>an option</b> when performing a merge or rebase
                <span class="code">--squash</span>.
              </p>
              <p class="text">
                To perform a squash merge, we need to execute the command <br />
                <span class="code">git merge --squash</span>.
              </p>
              <pre><code class="code-block language-plain">tree [hash of the merged tree]
parent [hash of the commit from main]
author [author name and email]
committer [committer name and email]

Squashed commit of [hash1, hash2, ..., hashN]</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Rebase</h2>
              <p class="text">
                In my opinion, rebase is the most confusing merge strategy in
                Git.
              </p>
              <p class="text">
                Take a look at the example below. We have two branches, which we
                want to merge.
              </p>
              <img src="assets/basic-rebase-1.png" alt="" class="image" />
              <div class="image-caption">
                Source:
                <a
                  href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing"
                  target="_blank"
                  >Git Book</a
                >
              </div>
              <p class="text">
                We can perform the three way merge, which will create a merge
                commit. But this approach <b>bloats the Git history</b>. At the
                diagram below it looks clean, but imagine a huge codebase with
                hundreds of merge commits.
              </p>
              <img src="assets/basic-rebase-2.png" alt="" class="image" />
              <div class="image-caption">
                Source:
                <a
                  href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing"
                  target="_blank"
                  >Git Book</a
                >
              </div>
              <p class="text">
                Solution for cleaner history is a <b>rebase</b>.
              </p>
              <p class="text">
                Rebasing is the process of moving or combining a sequence of
                commits to a new base commit.
              </p>
              <p class="text">
                Rebase takes all of the commits from the merged branch and
                <b>recreates them on top of the main branch</b>.
              </p>
              <img src="assets/basic-rebase-3.png" alt="" class="image" />
              <div class="image-caption">
                Source:
                <a
                  href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing"
                  target="_blank"
                  >Git Book</a
                >
              </div>
              <p class="text">
                <b>Warning:</b> All of the rebased commits will have a
                <b>new SHA-1</b>.
              </p>
              <p class="text text--label">
                Where does new SHA-1 come from? Take a look at the example
                below:
              </p>
              <pre><code class="code-block language-plain">$ git log --all --decorate --oneline --graph

* 96786c8 (HEAD -> experiment) C4
| * 36cfeec (master) C3
|/
* 8df361b C1
* 5b76239 C0

$ git cat-file -p experiment

tree b8785d053b387d3875c2a9a7c01f866cd521111f
parent 8df361b8265c1efcddeed0eb1c4bde371834d539
author Maciej Biel &lt;example@email.com&gt; 1694503064 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694503064 +0200

C4

$ git rebase master

First, rewinding head to replay your work on top of it...
Applying: C4

$ $ git log --all --decorate --oneline --graph

* 1fd56c1 (HEAD -> experiment) C4
* 36cfeec (master) C3
* 8df361b C1
* 5b76239 C0

$ git cat-file -p experiment

tree e2c05f73b8c3e41ada14b2b19d0c2966a1ecfd72
parent 36cfeec234eb0fd27b3e04db9800eb6aac6265d1
author Maciej Biel &lt;example@email.com&gt; 1694503064 +0200
committer Maciej Biel &lt;example@email.com&gt; 1694503262 +0200

C4
</code></pre>
              <p class="text">
                Look at the <span class="code">parent</span> header in the
                <span class="code">C4</span> commit before and after rebase:
              </p>
              <pre><code class="code-block language-plain"># Before rebase it points to C1
parent 8df361b8265c1efcddeed0eb1c4bde371834d539

# After rebase it points to C3
parent 36cfeec234eb0fd27b3e04db9800eb6aac6265d1</code></pre>
              <p class="text">
                That's why rebase is <b>dangerous</b>. The SHA-1 of the whole
                commit <b>must be re-calculated</b>, because the parent header
                changes in every rebased commit.
              </p>
              <p class="text">
                Rebase should be performed when <b>pulling changes</b> to your
                <b>local branch</b>, or when operating on multiple
                <b>local branches</b>.
              </p>
              <p class="text">
                Rebasing on a remote branchs, where multiple people are working
                on, is <b>a really bad idea</b>, and it will cause a lot of
                trouble.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Merge conflicts</h2>
              <p class="text">
                When the same parts of the same file are changed in two
                different branches, Git won't be able to
                <b>merge them automatically</b>, and a
                <b>merge conflict</b> occurs.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Example of a merge conflict</h2>
              <p class="text">
                Let's recreate the situation, when a merge conflict can occur.
              </p>
              <p class="text text--label">
                A one of many real world example, when the merge conflict can
                occur, is when the codebase has
                <b>inconsistent files formatting</b> and they don't always end
                up with <b>the newline</b>:
              </p>
              <pre><code class="code-block language-plain">$ git init
                
$ echo "file1" > file1.txt
$ git add file1.txt
$ git commit -m "Init commit"

$ git checkout -b feature
$ echo "file2" > file2.txt
$ git add file2.txt
$ git commit -m "Add file2 with newline"

$ git checkout master
$ echo -n "file2" > file2.txt
$ git add file2.txt
$ git commit -m "Add file2 without newline"

$ git log --all --graph --decorate --oneline

* 865a847 (HEAD -> master) Add file2 without newline
| * 72c692b (feature) Add file2 with newline
|/
* a2ac6b2 Init commit</code></pre>
              <p class="text">
                We created a <span class="code">file2.txt</span> <b>with</b> a
                newline on a <span class="code">feature</span> branch and a
                <span class="code">file2.txt</span> <b>without</b> a newline on
                a <span class="code">master</span> branch.
              </p>
              <p class="text text--label">
                Before merging, let's check the content of the
                <span class="code">.git/index</span>, you will see later why:
              </p>
              <pre><code class="code-block language-plain">$ git ls-files --stage

100644 08219db9b0969fa29cf16fd04df4a63964da0b69 0       file1.txt
100644 30d67d4672d5c05833b7192cc77a79eaafb5c7ad 0       file2.txt</code></pre>
              <p class="text text--label">
                Let's perform a merge of branch
                <span class="code">feature</span> into
                <span class="code">master</span>, which will
                <b>result in a conflict</b>:
              </p>
              <pre><code class="code-block language-plain">$ git merge feature

CONFLICT (add/add): Merge conflict in file2.txt
Auto-merging file2.txt
Automatic merge failed; fix conflicts and then commit the result.

$ cat file2.txt

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
file2
=======
file2
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</code></pre>
              <p class="text">
                <span class="code">file2.txt</span> from the feature branch
                contains on the second line of the file the newline character
                <span class="code">\n</span> and
                <span class="code">file2.txt</span> from the master branch
                doesn't even have a second line.
              </p>
              <p class="text">
                Git doesn't know which version of the file to use, so
                <b>it leaves the decision to the user</b>.
              </p>
              <p class="text">
                The <span class="code">file2.txt</span> contains the
                <b>conflict markers</b>
                <span class="code">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>,
                <span class="code">=======</span> and
                <span class="code">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> which
                indicates the conflicting parts of the file, which
                <b>we need to resolve</b>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">
                What happens when the merge conflict occurs
              </h2>
              <p class="text">
                Now we are in the middle of the
                <b>merge conflict resolution</b>. Most of the beginners at this
                point wants to quit using Git ðŸ˜‚.
              </p>
              <p class="text text--label">
                When you don't know what to do, type
                <span class="code">git status</span>. It usually gives you
                useful hints (just read what it says):
              </p>
              <pre><code class="code-block language-plain">$ git status

On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)
        both added:      file2.txt

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
              <p class="text">
                Good news, we can always without any consequences
                <b>abort the merge</b> with
                <span class="code">git merge --abort</span> and start over. But
                we will try to resolve the conflict.
              </p>
              <p class="text">
                How do Git know that we are in the middle of the merge conflict?
              </p>
              <p class="text text--label">
                Let's take a look, what's happening inside the
                <span class="code">.git/</span> directory. Some new files
                appeared:
              </p>
              <pre><code class="code-block language-plain">$ ll .git

...
-rw-r--r--  1 maciejb maciejb   41 Sep 13 19:53 MERGE_HEAD
-rw-r--r--  1 maciejb maciejb    0 Sep 13 19:53 MERGE_MODE
-rw-r--r--  1 maciejb maciejb   49 Sep 13 19:53 MERGE_MSG
...

$ cat .git/MERGE_HEAD
72c692be819987b796dddaeb19d43ef8b8bde2a6

$ cat .git/MERGE_MSG
Merge branch 'feature'

# Conflicts:
#       file2.txt

$ cat .git/MERGE_MODE</code></pre>
              <p class="text text--label">What are these files?</p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">MERGE_MODE</span> - Signals Git, whether we
                  want to force the <b>three way merge</b>. When we issue
                  <span class="code">git merge</span> without
                  <span class="code">--no-ff</span> parameter, this file is
                  empty, otherwise it contains the
                  <span class="code">no-ff</span> string.
                  <a
                    href="https://github.com/git/git/blob/d6c51973e4a0e889d1a426da08f52b9203fa1df2/builtin/commit.c#L1783"
                    target="_blank"
                    >You can read the source code as a proof.</a
                  >
                </li>
                <li class="list__item">
                  <span class="code">MERGE_HEAD</span> - Existence of this file
                  indicates, that there is <b>ongoing merge conflict</b>.
                  Contains the <b>SHA-1 hash</b> of the commit from the tip of
                  the branch, which we are merging into the current branch (in
                  our case <span class="code">feature</span> branch).
                </li>
                <li class="list__item">
                  <span class="code">MERGE_MSG</span> - contains the default
                  <b>commit message</b>, which the <b>merge commit</b> will
                  have.
                </li>
              </ul>
              <p class="text text--label">
                I mentioned previously, that the
                <span class="code">.git/index</span> is used when resolving the
                merge conflict. Let's check the content of the
                <span class="code">.git/index</span>:
              </p>
              <pre><code class="code-block language-plain">$ git ls-files --stage

100644 08219db9b0969fa29cf16fd04df4a63964da0b69 0       file1.txt
100644 30d67d4672d5c05833b7192cc77a79eaafb5c7ad 2       file2.txt
100644 6c493ff740f9380390d5c9ddef4af18697ac9375 3       file2.txt

$ git ls-files --debug
file1.txt
  ctime: 1694625281:485207678
  mtime: 1694625281:485207678
  dev: 2080     ino: 838905
  uid: 1000     gid: 1000
  size: 5       flags: 0
file2.txt
  ctime: 0:0
  mtime: 0:0
  dev: 0        ino: 0
  uid: 0        gid: 0
  size: 0       flags: 2000
file2.txt
  ctime: 0:0
  mtime: 0:0
  dev: 0        ino: 0
  uid: 0        gid: 0
  size: 0       flags: 3000</code></pre>
              <p class="text">
                We can notice, that <span class="code">file2.txt</span> is
                listed twice in the <span class="code">.git/index</span> file.
                The first entry has the <span class="code">flags</span> set to
                <span class="code">2</span> and the second entry has the
                <span class="code">flags</span> set to
                <span class="code">3</span>.
              </p>
              <p class="text text--label">
                The <span class="code">flags</span> are the
                <b>version numbers</b> or <b>stages</b> of the files in the
                <span class="code">.git/index</span>, numbered from
                <span class="code">0</span> to <span class="code">3</span>:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">0</span> - this flag means, that everything
                  is fine with the file, nothing to worry about.
                </li>
                <li class="list__item">
                  <span class="code">1</span> - also called <b>base</b> - the
                  common ancestor of the file, the version of the file before
                  the changes were made.
                </li>
                <li class="list__item">
                  <span class="code">2</span> - also called <b>ours</b> - the
                  version of the file from the branch we are merging from.
                </li>
                <li class="list__item">
                  <span class="code">3</span> - also called <b>theirs</b> - the
                  version of the file from the branch we are merging into the
                  current branch.
                </li>
              </ul>
              <p class="text">
                Flag <span class="code">0</span> means the file <b>is clean</b>,
                and flags <span class="code">1</span>,
                <span class="code">2</span> and
                <span class="code">3</span> signals Git, that the
                <b>file is conflicted</b> and you are in the
                <b>middle of the merge conflict</b>.
              </p>
              <p class="text">
                Now, let's fix the conflict. To do that,
                <b>delete the conflict markers</b> and leave only the content of
                the file, which you <b>want to keep</b>.
              </p>
              <p class="text text--label">
                Our file2.txt <b>will look like this</b> (by the way adding
                newlines is a good practice and it's POSIX compliant):
              </p>
              <pre><code class="code-block language-plain">file2
              </code></pre>
              <p class="text text--label">
                To tell the Git, that we resolved the conflict in a file, we
                need to <b>stage</b> the file with
                <span class="code">git add</span> command. You have to stage
                <b>every file</b> with resolved conflict to
                <b>finish the merge</b>:
              </p>
              <pre><code class="code-block language-plain">git add file2.txt</code></pre>
              <p class="text text--label">
                Let's run the <span class="code">git status</span> again and
                read what it says:
              </p>
              <pre><code class="code-block language-plain">$ git status

On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:
        modified:   file2.txt</code></pre>
              <p class="text text--label">
                Now everything is fine and <b>we can commit</b>, but before
                commiting, let's check the content of the
                <span class="code">.git/index</span> again:
              </p>
              <pre><code class="code-block language-plain">$ git ls-files --stage

100644 08219db9b0969fa29cf16fd04df4a63964da0b69 0       file1.txt
100644 94121facf433f4f8f095cd23578d744c38c8e225 0       file2.txt</code></pre>
              <p class="text text--label">
                When all of the conflicts are resolved, we can commit the merge
                and that's it:
              </p>
              <pre><code class="code-block language-plain">$ git commit</code></pre>
              <p class="text">
                That's how you deal with the merge conflicts.
                <b>It's not that hard, right?</b>
              </p>
              <p class="text text--label">
                Also, you <b>don't have to manually</b> resolve conflicts using
                the text editor, but you can do it automatically from the
                command line:
              </p>
              <pre><code class="code-block language-plain"># Grab the version of the file from the branch we are merging from

$ git checkout --ours file2.txt

# Grab the version of the file from the branch we are merging into the current branch

$ git checkout --theirs file2.txt</code></pre>
              <p class="text">
                Now you know from the <span class="code">.git/index</span>,
                where does names of the parameters
                <span class="code">--ours</span> and
                <span class="code">--theirs</span> come from.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Cherry pick</h2>
              <p class="text">
                Cherry-picking is a process of applying single commit from
                <b>one branch to another</b>.
              </p>
              <p class="text text--label">
                To perform cherry-pick, checkout to branch, on which you want to
                apply particular commit, and <b>pick desired commit</b>:
              </p>
              <pre><code class="code-block language-plain">$ git cherry-pick &lt;commit SHA-1&gt;</code></pre>
              <p class="text">
                Cherry-picked commit is a <b>new commit</b> applied on top of a
                <b>current branch</b>. It is a <b>new object</b> in the Git.
              </p>
              <pre><code class="code-block language-plain">$ git checkout master

$ git log --all --decorate --oneline --graph

* 865a847 (HEAD -> master) Add file2 without newline
| * e6d01a1 (mybranch) Add file3
|/
| * 72c692b (feature) Add file2 with newline
|/
* a2ac6b2 Init commit

$ git cherry-pick mybranch

[master 2915c9f] Add file3
 Date: Wed Sep 13 22:12:09 2023 +0200
 1 file changed, 1 insertion(+)
 create mode 100644 file3.txt

$ git log --all --decorate --oneline --graph

* 2915c9f (HEAD -> master) Add file3
* 865a847 Add file2 without newline
| * e6d01a1 (mybranch) Add file3
|/
| * 72c692b (feature) Add file2 with newline
|/
* a2ac6b2 Init commit</code></pre>
              <p class="text">
                Cherry-picked commit <b>does not have any references</b> to the
                branch it was picked from. It has a single
                <span class="code">parent</span> header which points to the
                previous <span class="code">HEAD</span>.
              </p>
              <p class="text">
                When a merge conflict occurs during cherry-picking, Git performs
                a
                <b>three way merge</b>, and the procedure of dealing with the
                merge conflicts is the same as in the section above.
              </p>
              <p class="text text--label">
                During the <b>merge conflict</b> while cherry-picking, two new
                files appears inside the
                <span class="code">.git/</span> directory:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">CHERRY_PICK_HEAD</span> - Existence of this
                  file indicates, that there is <b>ongoing merge conflict</b>.
                </li>
                <li class="list__item">
                  <span class="code">CHERRY_PICK_MSG</span> - contains the
                  default <b>commit message</b>, which the
                  <b>merge commit</b> will have.
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Tags</h2>
              <p class="text">
                Tags in Git are used to <b>mark specific points</b> in the
                commit history of a repository, typically to label important or
                stable versions, making it easier to reference and navigate to
                those points.
              </p>
              <p class="text text--label">
                There are two types of tags in the Git:
              </p>
              <ul class="list">
                <li class="list__item">
                  <b>Lightweight</b> - they are very similar to branches
                </li>
                <li class="list__item">
                  <b>Annotated</b> - they are similar to commits
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Lightweight Tags</h2>
              <p class="text">
                Lightweight tag is just a <b>reference to a commit</b>. Almost
                the same as a branch.
              </p>
              <p class="text text--label">
                Lightweight tags are stored in the
                <span class="code">.git/refs/tags</span> directory:
              </p>
              <pre><code class="code-block language-plain">$ git tag mytag

$ git log --all --decorate --oneline --graph

* 1fd56c1 (HEAD -> experiment, tag: mytag) C4
* 36cfeec (master) C3
* 8df361b C1
* 5b76239 C0

$ ls -al .git/refs/tags

total 12
drwxr-xr-x 2 maciejb maciejb 4096 Sep 12 10:17 .
drwxr-xr-x 4 maciejb maciejb 4096 Sep 12 09:16 ..
-rw-r--r-- 1 maciejb maciejb   41 Sep 12 10:17 mytag

$ cat .git/refs/tags/mytag

1fd56c10458361b4b127f3de256dfc8b216a112e</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Annotated Tags</h2>
              <p class="text">
                Annotated <span class="code">tag</span> is fourth type of object
                in the Git. It's a <b>commit-like object</b>, which stores
                informations, about the tagger, date, message, and the commit it
                points to.
              </p>
              <p class="text">
                <b>Annotated tags</b> are stored in the
                <span class="code">.git/objects/</span> directory.
              </p>
              <p class="text">
                Annotated tag also <b>creates a reference</b> in the
                <span class="code">.git/refs/tags/</span> directory like a
                lightweight tags, but the reference points to the new annotated
                <span class="code">tag</span> object, not to the
                <span class="code">commit</span>.
              </p>
              <p class="text">
                To create an annotated tag, use the
                <span class="code">git tag -a</span> with the
                <span class="code">-a</span> flag. The command
                <span class="code">git show-ref --tags</span> displays all the
                tags (lightweight and annotated) in the repository.
              </p>
              <p class="text text--label">Check out the example below:</p>
              <pre><code class="code-block language-plain">$ git tag -a v1.0 -m "my version 1.0"

$ git log --all --decorate --oneline --graph

* 1fd56c1 (HEAD -> experiment, tag: v1.0, tag: mytag) C4
* 36cfeec (master) C3
* 8df361b C1
* 5b76239 C0

$ git show-ref --tags
1fd56c10458361b4b127f3de256dfc8b216a112e refs/tags/mytag
d62676dd152b3e984221500a293cf073bb1a4c9c refs/tags/v1.0

$ git cat-file -t v1.0

tag

$ git cat-file -p v1.0

object 1fd56c10458361b4b127f3de256dfc8b216a112e
type commit
tag v1.0
tagger Maciej Biel &lt;example@email.com&gt; 1694506994 +0200

my version 1.0

$ git cat-file -p d62676dd15

object 1fd56c10458361b4b127f3de256dfc8b216a112e
type commit
tag v1.0
tagger Maciej Biel &lt;example@email.com&gt; 1694506994 +0200

my version 1.0</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Stash</h2>
              <p class="text">
                Stashing allows you to <b>temporarily save</b> uncommited
                changes to your working directory, which you can
                <b>restore later</b>.
              </p>
              <p class="text">
                You can't switch to another branch, when you have
                <b>uncommited changes</b> (except untracked files). Stash allows
                you to store this changes for later, so you can switch to
                another branch with clean tree.
              </p>
              <p class="text text--label">
                Simple example of the
                <span class="code">git stash</span> command usage:
              </p>
              <pre><code class="code-block language-plain">$ git status

On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
        modified:   file3.txt

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        file2.txt

no changes added to commit (use "git add" and/or "git commit -a")

$ git stash

Saved working directory and index state WIP on master: 886115e Second commit

$ git status

On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        file2.txt

nothing added to commit but untracked files present (use "git add" to track)

$ git stash pop

On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
        modified:   file3.txt

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        file2.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (3df8ef0900999f167abdfe6f0332d5d7bf311b43)

$  git stash -u

Saved working directory and index state WIP on master: 886115e Second commit

$  git status

On branch master
nothing to commit, working tree clean</code></pre>
              <p class="text text--label">
                What happened in the example above:
              </p>
              <ul class="list">
                <li class="list__item">
                  We stashed files from our <b>working directory</b> with the
                  <span class="code">git stash</span> command.
                </li>
                <li class="list__item">
                  Stash by default saves changes made to
                  <span class="code">tracked</span> files, and skips
                  <span class="code">untracked</span>.
                </li>
                <li class="list__item">
                  We restored our working directory with the
                  <span class="code">git stash pop</span> command.
                </li>
                <li class="list__item">
                  We stashed again the files, but this time
                  <b>including untracked</b> ones with the
                  <span class="code">git stash -u</span> command.
                </li>
                <li class="list__item">The working tree is now clean.</li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Stash objects and stash stack</h2>
              <p class="text text--label">
                Stashes forms in a <b>stack</b> data structure. You can list all
                stashes with the
                <span class="code">git stash list</span> command:
              </p>
              <pre><code class="code-block language-plain">$ git stash list

stash@{0}: WIP on master: 5a9572e New commit
stash@{1}: WIP on master: 886115e Second commit</code></pre>
              <p class="text text--label">
                What exactly <b>is a stash</b>? A new file appeared in the
                <span class="code">.git/refs</span> directory. Let's inspect it
                with a <span class="code">git cat-file</span> command:
              </p>
              <pre><code class="code-block language-plain">$ ll .git/refs

total 12K
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 14 15:09 heads
-rw-r--r-- 1 maciejb maciejb   41 Sep 14 15:09 stash
drwxr-xr-x 2 maciejb maciejb 4.0K Sep 14 12:47 tags

$ cat .git/refs/stash

bb3a17acb5e1e7d05af08b6ca90ad5ef6a6fb1e1</code></pre>
              <p class="text text--label">
                As you can see, Git created a new reference file called
                <span class="code">stash</span>, which points to a
                <b>new commit</b>. So a <b>single stash</b> is just a
                <b>commit</b>. It's message is the same as in stashes list:
              </p>
              <pre><code class="code-block language-plain">$ git cat-file -p bb3a17acb5

tree a383a1592d6370cac33a3f8d0fa9029ca0782b51
parent 5a9572ed0e16fc3dd0dd8bbf026383a27f05aec7
parent 2632c30af348deb6814317c1b3fa5aadf914fb2c
author Maciej Biel &lt;example@email.com,&gt; 1694696951 +0200
committer Maciej Biel &lt;example@email.com,&gt; 1694696951 +0200

WIP on master: 5a9572e New commit

$ git cat-file -t bb3a17acb5

commit</code></pre>
              <p class="text">
                You can <b>apply stash</b> from the list with the
                <span class="code">git stash pop</span> command, which is
                combination of <span class="code">git stash apply</span> and
                <span class="code">git stash drop</span>.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Reflog</h2>
              <p class="text">
                The name <b>reflog</b> is short for <b>reference log</b>.
              </p>
              <p class="text">
                Reference logs is a <b>set of all commits</b>, to which the
                <span class="code">HEAD</span> was pointing back to the time
                when the initial commit was created.
              </p>
              <p class="text">
                Reference logs are created when the tips of branches and other
                references in the repository are updated.
              </p>
              <p class="text">
                Reference logs are stored in the
                <span class="code">.git/refs/logs/</span>.
              </p>
              <p class="text">
                We can access the reflog by typing
                <span class="code">git reflog</span>, which executes
                <span class="code">git reflog show</span>, which is alias to
                <span class="code"
                  >git log -g --abbrev-commit --pretty=oneline</span
                >.
              </p>
              <pre><code class="code-block language-plain">1fd56c1 (HEAD -> experiment, tag: v1.0, tag: mytag) HEAD@{0}: rebase finished: returning to refs/heads/experiment
1fd56c1 (HEAD -> experiment, tag: v1.0, tag: mytag) HEAD@{1}: rebase: C4
36cfeec (master) HEAD@{2}: rebase: checkout master
96786c8 HEAD@{3}: commit: C4
8df361b HEAD@{4}: checkout: moving from 8df361b8265c1efcddeed0eb1c4bde371834d539 to experiment
8df361b HEAD@{5}: checkout: moving from master to 8df361b
36cfeec (master) HEAD@{6}: commit: C3
8df361b HEAD@{7}: commit: C1
5b76239 HEAD@{8}: commit (initial): C0</code></pre>
              <p class="text">
                <span class="code">HEAD@{2}</span> - this notation means, where
                the <span class="code">HEAD</span> was two reference updates
                before.
              </p>
              <p class="text">
                <b>Notice</b>: Reflog history is
                <b>stored only locally!</b> It's not included when pushing to
                remote.
              </p>
              <p class="text">
                Reflog is extremely useful when we want to <b>undo</b> some of
                your operations. Remember, that you can't undo deletion of
                uncommited and untracked files from the working directory.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">.keep</h2>
              <p class="text">
                Git by default <b>doesn't add empty directories</b> to the
                repository.
              </p>
              <p class="text">
                A convinient way to add empty directories to the repository is
                to put an empty file called
                <span class="code">.keep</span> inside the directory.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Remote config</h2>
              <p class="text">
                Configuration of the remote repository is stored in the
                <span class="code">.git/config</span> file. Informations about
                origins are stored there.
              </p>
              <p class="text text--label">
                I will show you an example of the configuration in one of my
                repositories:
              </p>
              <pre><code class="code-block language-plain">$ cat .git/config

[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = git@github.com:maciejb2k/chronlife.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
        remote = origin
        merge = refs/heads/main</code></pre>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Remote branches</h2>
              <p class="text">
                Remote branches are stored in the <br />
                <span class="code">.git/refs/remotes/[origin name]</span>
                directory.
              </p>
              <p class="text">
                They behave the same as local branches. They are updated on the
                <span class="code">git fetch</span> command.
              </p>
              <pre><code class="code-block language-plain">$ ll .git/refs/remotes/origin

total 8.0K
drwxr-xr-x 3 maciejb maciejb 4.0K Aug 30 09:35 dependabot
-rw-r--r-- 1 maciejb maciejb   41 Sep  5 16:07 main</code></pre>
              <p class="text">
                When local branches are connected with the remote ones, they are
                called <b>tracking / upstream branches</b>.
              </p>
              <p class="text">
                With upstream branches, Git will know where to push and pull
                changes without explicility specifying the remote and branch
                name.
              </p>
              <pre><code class="code-block language-plain">$ git checkout -b [branch] [remote]/[branch]
$ git checkout --track origin/serverfix
$ git checkout serverfix</code></pre>
              <p class="text text--label">
                To display all references, local and remote in the repository,
                use the <span class="code">git ls-remote origin</span> command.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">Fetch vs Pull</h2>
              <p class="text">
                The <span class="code">git fetch</span> command is very
                mysterious, but with knowledge from previous sections about the
                Git objects and merging strategies, it is <b>easy and clear</b>.
              </p>
              <p class="text">
                This command fetches all new objects from the remote repository
                to the <span class="code">.git/objects/</span> directory. These
                new objects will show up as a commits and tags in the
                <span class="code">git log</span> command.
              </p>
              <p class="text">
                At this point, <b>everything is up to you</b>, whether you want
                to merge your local branch with the remote branch, or rebase
                your local branch on top of the remote branch.
              </p>
              <p class="text">
                Prerequisite for the
                <span class="code">git fetch</span> command is ability to merge
                branches and deal with optional conflicts.
              </p>
              <p class="text">
                The <span class="code">git pull</span> /
                <span class="code">git pull --rebase</span> commands performs at
                the same time <span class="code">git fetch</span> and
                <span class="code">git merge</span> /
                <span class="code">git rebase</span> commands. It is faster in
                use, but you have less control over the process.
              </p>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">
                What is inside .git/ directory?
              </h2>
              <p class="text text--label">
                Below is the list of files and directories with explanations:
              </p>
              <ul class="list">
                <li class="list__item">
                  <span class="code">.git/refs/</span> - references to commits
                  and tags.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/heads/</span> - refs to local
                  branches.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/heads/[brach name]</span> - ref
                  to latest commit on branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/remotes/</span> - refs to remote
                  branches.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/remotes/[origin name]/</span> -
                  refs for multiple origins.
                </li>
                <li class="list__item">
                  <span class="code"
                    >.git/refs/remotes/[origin name]/[branch name]</span
                  >
                  - ref to latest commit on remote branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/remotes/[origin name]/HEAD</span>
                  - stores default branch for named remote
                  <span class="code">git remote set-head [branch]</span>.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/tags/</span> - refs to the
                  lightweight tags.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/tags/[tag name]</span> - ref to
                  the tag.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/notes/</span> - stores notes from
                  the git notes.
                </li>
                <li class="list__item">
                  <span class="code">.git/refs/notes/commits</span> - points to
                  the latest note-commit.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/</span> - all of the git
                  objects lives here
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/info/</span> - additional
                  information about the object store is recorded in this
                  directory.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/info/alternates</span> - paths
                  to alternate object stores that this object store borrows
                  objects from, one pathname per line.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/info/packs</span> - list with
                  names of the packfiles.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/info/commit-graph</span> -
                  binary file storing the commit graph.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/pack/</span> - contains
                  packfiles.
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/pack/[packfile].pack</span> -
                  single packfile
                </li>
                <li class="list__item">
                  <span class="code">.git/objects/pack/[packfile].idx</span> -
                  index for the packfile.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/</span> - contains logs.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/HEAD</span> - changes made to the
                  current branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/refs/</span> - logs about
                  branches.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/refs/heads/</span> - logs about
                  local branches.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/refs/heads/[branch name]</span> -
                  single log file for the local branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/refs/remotes/</span> - logs about
                  the remote branches.
                </li>
                <li class="list__item">
                  <span class="code">.git/logs/refs/remotes/[origin name]</span>
                  - logs about single origin.
                </li>
                <li class="list__item">
                  <span class="code"
                    >.git/logs/refs/remotes/[origin name]/[branch name]</span
                  >
                  - log file for single remote branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/branches/</span> - let me know if you
                  found out, what is this directory used for.
                </li>
                <li class="list__item">
                  <span class="code">.git/hooks/</span> - directory with hooks,
                  populated with templates.
                </li>
                <li class="list__item">
                  <span class="code">.git/hooks/[hook name]</span> - single
                  hook.
                </li>
                <li class="list__item">
                  <span class="code">.git/info/</span> - contains additional
                  info about the repository.
                </li>
                <li class="list__item">
                  <span class="code">.git/info/refs</span> - contains list of
                  all the references in the repository.
                </li>
                <li class="list__item">
                  <span class="code">.git/info/exclude</span> - contains
                  patterns for the files which Git will ignore.
                </li>
                <li class="list__item">
                  <span class="code">.git/index</span> - index / staging area.
                </li>
                <li class="list__item">
                  <span class="code">.git/HEAD</span> - contains reference to
                  the current used branch.
                </li>
                <li class="list__item">
                  <span class="code">.git/ORIG_HEAD</span> - contains SHA-1 of
                  the commit that the branch was previously on before moving
                  HEAD.
                </li>
                <li class="list__item">
                  <span class="code">.git/MERGE_HEAD</span> - contains SHA-1 of
                  the commit that is being merged during the merge.
                </li>
                <li class="list__item">
                  <span class="code">.git/CHERRY_PICK_HEAD</span> contains SHA-1
                  of the commit this is being cherry picked during the
                  cherry-pick.
                </li>
                <li class="list__item">
                  <span class="code">.git/FETCH_HEAD</span> - contains lines
                  with information about the fetched branches and their updates
                </li>
                <li class="list__item">
                  <span class="code">.git/COMMIT_EDITMSG</span> - this file is
                  created when Git invokes the editor to write a commit message.
                  Once closed, Git will use the content of this file as the
                  commit message.
                </li>
                <li class="list__item">
                  <span class="code">.git/description</span> - only used by
                  GitWeb.
                </li>
                <li class="list__item">
                  <span class="code">.git/config</span> - local repository
                  config.
                </li>
                <li class="list__item">
                  <span class="code">.git/packed-refs</span> - this is a file in
                  the Git repository, that contains a compact representation of
                  references, including remote branches.
                </li>
              </ul>
            </div>
            <div class="group">
              <h2 class="heading heading--h2">
                How does the Git commands works under the hood?
              </h2>
              <p class="text">
                That's all about basic Git concepts. I will definitely add more
                content in the future.
              </p>
              <p class="text">
                The continuation of this guide will be about
                <b>how most of the Git commands works under the hood</b>. I
                strongly recommend you to read my article about it:
              </p>
              <p class="text">
                <a
                  href="https://dev-blog.maciejbiel.pl/git-commands-overview/"
                  target="_blank"
                  >https://dev-blog.maciejbiel.pl/git-commands-overview/</a
                >
              </p>
            </div>
          </main>
          <footer class="footer">
            <p>Â© 2023 <b>Maciej Biel</b></p>
          </footer>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="js/main.js"></script>
  </body>
</html>
